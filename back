import io
import os
import time
import hmac
import hashlib
import secrets
from datetime import datetime
from typing import Dict, Optional

import requests
import streamlit as st
from PIL import Image, ImageFilter, ImageOps
import textwrap


# ============================================================
# Kakao OAuth for Streamlit (No-session CSRF using HMAC state)
# - ìš°ìƒë‹¨ ê³ ì • ë„¤ë¹„ë°”(í™”ì´íŠ¸, ë¼ìš´ë“œ, ê·¸ë¦¼ì)
# - ì‚¬ì´ë“œë°” ìˆ¨ê¹€
# - ë¡œê·¸ì¸ ì „: "ì¹´ì¹´ì˜¤ ë¡œê·¸ì¸" ë…¸ë€ ë²„íŠ¼
# - ë¡œê·¸ì¸ í›„: "ë¡œê·¸ì•„ì›ƒ" + ì›í˜• í”„ë¡œí•„ ì•„ë°”íƒ€
# - CSRF state: ì„¸ì…˜ì— ì•ˆ ì €ì¥. HMAC ì„œëª… í† í°ìœ¼ë¡œ ê²€ì¦ â†’ ì„¸ì…˜ ê°ˆë ¤ë„ OK.
# ============================================================


# ------------------------------[ 0) í˜ì´ì§€/ë ˆì´ì•„ì›ƒ ]---------------------------
st.set_page_config(layout="wide", initial_sidebar_state="collapsed")

st.markdown(
    """
<style>
 [data-testid="stSidebar"]{ display:none !important; }
    [data-testid="collapsedControl"]{ display:none !important; }

    .navbar {
    position: fixed;
    top: 0; left: 0; right: 0;
    height: 60px;
    padding: 0 18px;
    background: #ffffff;
    display: flex; align-items: center; justify-content: flex-end;
    box-shadow: 0 2px 6px rgba(0,0,0,0.06);
    z-index: 1000;
    }
    .block-container { padding-top: 78px; }

    .kakao-btn{
    display:inline-flex; align-items:center; gap:8px;
    padding:10px 14px; background:#FEE500; color:#000 !important;
    border:1px solid rgba(0,0,0,.08); border-radius:10px;
    font-weight:700; text-decoration:none !important;
    box-shadow:0 1px 2px rgba(0,0,0,.08); cursor:pointer;
    }
    .kakao-btn:hover{ filter:brightness(0.96); }

    .logout-btn{
    display:inline-flex; align-items:center;
    padding:9px 12px; margin-right:8px;
    background:#fff; color:#222 !important;
    border:1px solid #E5E7EB; border-radius:10px;
    font-weight:600; text-decoration:none !important; cursor:pointer;
    }
    .logout-btn:hover{ background:#F9FAFB; }

    .avatar{
    width:40px; height:40px; border-radius:50%; object-fit:cover;
    border:1px solid #E5E7EB; box-shadow:0 1px 2px rgba(0,0,0,0.05);
    }

    .nav-right{ display:flex; align-items:center; gap:10px; }
</style>
""",
    unsafe_allow_html=True,
)


# ------------------------------[ 1) ì¹´ì¹´ì˜¤ OAuth ì„¤ì • ]------------------------
REST_API_KEY = os.getenv("KAKAO_REST_API_KEY")
REDIRECT_URI = os.getenv("KAKAO_REDIRECT_URI", "http://localhost:8501")
STATE_SECRET = (
    os.getenv("KAKAO_STATE_SECRET")
    or os.getenv("OAUTH_STATE_SECRET")
    or (REST_API_KEY or "dev-secret")
)

AUTHORIZE_URL = "https://kauth.kakao.com/oauth/authorize"
TOKEN_URL = "https://kauth.kakao.com/oauth/token"
USERME_URL = "https://kapi.kakao.com/v2/user/me"

STATE_TTL_SEC = 5 * 60


def _hmac_sha256(key: str, msg: str) -> str:
    return hmac.new(key.encode(), msg.encode(), hashlib.sha256).hexdigest()


def make_state() -> str:
    ts = str(int(time.time()))
    nonce = secrets.token_urlsafe(8)
    raw = f"{ts}.{nonce}"
    sig = _hmac_sha256(STATE_SECRET, raw)
    return f"{raw}.{sig}"


def verify_state(state: str) -> bool:
    if not state or state.count(".") != 2:
        return False
    ts, nonce, sig = state.split(".")
    expected = _hmac_sha256(STATE_SECRET, f"{ts}.{nonce}")
    if not hmac.compare_digest(sig, expected):
        return False
    try:
        ts_i = int(ts)
    except ValueError:
        return False
    if time.time() - ts_i > STATE_TTL_SEC:
        return False
    return True


def build_auth_url() -> str:
    state = make_state()
    return (
        f"{AUTHORIZE_URL}"
        f"?client_id={REST_API_KEY}"
        f"&redirect_uri={REDIRECT_URI}"
        f"&response_type=code"
        f"&state={state}"
    )


def exchange_code_for_token(code: str) -> dict:
    data = {
        "grant_type": "authorization_code",
        "client_id": REST_API_KEY,
        "redirect_uri": REDIRECT_URI,
        "code": code,
    }
    response = requests.post(TOKEN_URL, data=data, timeout=10)
    response.raise_for_status()
    return response.json()


def get_user_profile(access_token: str) -> dict:
    response = requests.get(
        USERME_URL,
        headers={"Authorization": f"Bearer {access_token}"},
        timeout=10,
    )
    response.raise_for_status()
    return response.json()


def extract_profile(user_me: dict):
    account = (user_me or {}).get("kakao_account", {}) or {}
    profile = account.get("profile", {}) or {}
    nickname = profile.get("nickname") or None
    img = profile.get("profile_image_url") or profile.get("thumbnail_image_url") or None
    if not nickname or not img:
        props = (user_me or {}).get("properties", {}) or {}
        nickname = nickname or props.get("nickname")
        img = img or props.get("profile_image") or props.get("thumbnail_image")
    return nickname, img


# ------------------------------[ 2) ì½œë°±/ë¡œê·¸ì•„ì›ƒ ì²˜ë¦¬ ]------------------------
_query_params = (
    st.query_params if hasattr(st, "query_params") else st.experimental_get_query_params()
)


def _first_param(name: str):
    value = _query_params.get(name)
    return value[0] if isinstance(value, list) and value else value


if _first_param("logout") == "1":
    st.session_state.pop("kakao_token", None)
    st.session_state.pop("kakao_profile", None)
    if hasattr(st, "query_params"):
        st.query_params.clear()
    else:
        st.experimental_set_query_params()
    st.rerun()


error = _first_param("error")
error_description = _first_param("error_description")
code = _first_param("code")
state = _first_param("state")

if error:
    st.error(f"ì¹´ì¹´ì˜¤ ì¸ì¦ ì—ëŸ¬: {error}\n{error_description or ''}")
elif code:
    if not verify_state(state):
        st.error("state ê²€ì¦ ì‹¤íŒ¨(CSRF/ë§Œë£Œ). ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.")
    else:
        try:
            token_json = exchange_code_for_token(code)
            st.session_state.kakao_token = token_json
            st.session_state.kakao_profile = get_user_profile(token_json["access_token"])
            if hasattr(st, "query_params"):
                st.query_params.clear()
            else:
                st.experimental_set_query_params()
            st.rerun()
        except requests.HTTPError as exc:
            st.exception(exc)


# ------------------------------[ 3) ìš°ìƒë‹¨ ë„¤ë¹„ë°” ]-----------------------------
auth_url = build_auth_url()
nickname, img_url = None, None
if "kakao_profile" in st.session_state:
    nickname, img_url = extract_profile(st.session_state["kakao_profile"])

nav_parts = ["<div class='navbar'><div class='nav-right'>"]
if "kakao_token" not in st.session_state:
    nav_parts.append(f"<a class='kakao-btn' href='{auth_url}'>ì¹´ì¹´ì˜¤ ë¡œê·¸ì¸</a>")
else:
    nav_parts.append("<a class='logout-btn' href='?logout=1'>ë¡œê·¸ì•„ì›ƒ</a>")
    if img_url:
        safe_nick = (nickname or "").replace("<", "&lt;").replace(">", "&gt;")
        nav_parts.append(
            f"<img class='avatar' src='{img_url}' alt='avatar' title='{safe_nick}'/>"
        )
nav_parts.append("</div></div>")
st.markdown("\n".join(nav_parts), unsafe_allow_html=True)


# ------------------------------[ 4) ë³µì› ìœ í‹¸ í•¨ìˆ˜ ]---------------------------
def ensure_restoration_state() -> Dict:
    if "restoration" not in st.session_state:
        st.session_state.restoration = {
            "upload_digest": None,
            "original_bytes": None,
            "photo_type": None,
            "description": "",
            "current_bytes": None,
            "counts": {"color": 0, "upscale": 0, "denoise": 0, "story": 0},
            "history": [],
            "story": None,
        }
    return st.session_state.restoration


def image_from_bytes(data: bytes) -> Image.Image:
    image = Image.open(io.BytesIO(data))
    image = ImageOps.exif_transpose(image)
    return image.convert("RGB")


def image_to_bytes(image: Image.Image) -> bytes:
    buffer = io.BytesIO()
    image.save(buffer, format="PNG")
    return buffer.getvalue()


def colorize_image(image: Image.Image) -> Image.Image:
    gray = image.convert("L")
    colorized = ImageOps.colorize(gray, black="#1e1e1e", white="#f8efe3", mid="#88a6c6")
    return colorized.convert("RGB")


def upscale_image(image: Image.Image) -> Image.Image:
    width, height = image.size
    factor = 2
    return image.resize((width * factor, height * factor), Image.LANCZOS)


def denoise_image(image: Image.Image) -> Image.Image:
    smoothed = image.filter(ImageFilter.MedianFilter(size=3))
    return smoothed.filter(ImageFilter.SMOOTH_MORE)


def format_status(counts: Dict[str, int]) -> str:
    return (
        f"[ì»¬ëŸ¬í™” {'âœ”' if counts['color'] else 'âœ–'} / "
        f"í•´ìƒë„ {counts['upscale']}íšŒ / ë…¸ì´ì¦ˆ {counts['denoise']}íšŒ]"
    )


def add_history_entry(label: str, image_bytes: bytes, note: Optional[str] = None):
    restoration = ensure_restoration_state()
    entry = {
        "label": label,
        "bytes": image_bytes,
        "status": dict(restoration["counts"]),
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "note": note,
    }
    restoration["history"].append(entry)
    restoration["current_bytes"] = image_bytes


def reset_restoration(upload_digest: str, original_bytes: bytes, photo_type: str, description: str):
    restoration = ensure_restoration_state()
    restoration.update(
        {
            "upload_digest": upload_digest,
            "original_bytes": original_bytes,
            "photo_type": photo_type,
            "description": description,
            "current_bytes": original_bytes,
            "counts": {"color": 0, "upscale": 0, "denoise": 0, "story": 0},
            "history": [],
            "story": None,
        }
    )


def build_story(description: str, counts: Dict[str, int], photo_type: str) -> str:
    base = description.strip() or "ì´ ì‚¬ì§„"
    story_lines = []

    intro = f"{base}ì€(ëŠ”) ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ ë³µì› ê³¼ì •ì„ ê±°ì¹˜ê³  ìˆìŠµë‹ˆë‹¤."
    story_lines.append(intro)

    if photo_type == "í‘ë°±":
        if counts["color"]:
            story_lines.append(
                "í‘ë°±ìœ¼ë¡œ ë‚¨ì•„ ìˆë˜ ìˆœê°„ì— ìƒ‰ì„ ë§ì…íˆì ìŠí˜”ë˜ ì˜¨ê¸°ì™€ ê³µê¸°ê°€ ë˜ì‚´ì•„ë‚¬ìŠµë‹ˆë‹¤."
            )
        else:
            story_lines.append("ì•„ì§ ìƒ‰ì„ ì…íˆì§€ ëª»í•œ ì±„ ì‹œê°„ ì†ì—ì„œ ê¸°ë‹¤ë¦¬ê³  ìˆìŠµë‹ˆë‹¤.")

    if counts["upscale"]:
        story_lines.append(
            f"ì„¸ë¶€ ë¬˜ì‚¬ë¥¼ ì‚´ë¦¬ê¸° ìœ„í•´ í•´ìƒë„ ë³´ì •ì„ {counts['upscale']}íšŒ ë°˜ë³µí•˜ë©° íë¦¿í–ˆë˜ ìœ¤ê³½ì„ ë˜ë ·í•˜ê²Œ ë‹¤ë“¬ì—ˆìŠµë‹ˆë‹¤."
        )
    if counts["denoise"]:
        story_lines.append(
            f"ì¡ìŒì„ ì •ë¦¬í•˜ëŠ” ê³¼ì •ë„ {counts['denoise']}íšŒ ì§„í–‰ë˜ì–´ ì‚¬ì§„ ì† ì¸ë¬¼ì˜ í‘œì •ê³¼ ë°°ê²½ì´ í•œì¸µ ì°¨ë¶„í•´ì¡ŒìŠµë‹ˆë‹¤."
        )

    if not counts["upscale"] and not counts["denoise"] and counts["color"]:
        story_lines.append("ìƒ‰ë§Œ ë”í–ˆì„ ë¿ì¸ë°ë„ ì¥ë©´ì˜ ê°ì •ì´ ì‚´ì•„ ì›€ì§ì´ëŠ” ë“¯í•©ë‹ˆë‹¤.")

    climax = (
        "ë³µì›ëœ ì´ë¯¸ì§€ë¥¼ ë°”ë¼ë³´ëŠ” ì§€ê¸ˆ, ì‚¬ì§„ ì† ì´ì•¼ê¸°ê°€ í˜„ì¬ì˜ ìš°ë¦¬ì—ê²Œ ë§ì„ ê±´ë„¤ëŠ” ë“¯í•©ë‹ˆë‹¤."
    )
    story_lines.append(climax)

    outro = "ì´ ì¥ë©´ì´ ì „í•˜ê³  ì‹¶ì€ ë©”ì‹œì§€ê°€ ìˆë‹¤ë©´, ê·¸ê²ƒì€ ê¸°ì–µì„ ê³„ì† ì´ì–´ê°€ìëŠ” ë§ˆìŒì¼ì§€ë„ ëª¨ë¦…ë‹ˆë‹¤."
    story_lines.append(outro)

    wrapped = [textwrap.fill(line, width=46) for line in story_lines]
    return "\n\n".join(wrapped)


def handle_auto_colorization(photo_type: str):
    restoration = ensure_restoration_state()
    if photo_type != "í‘ë°±":
        return
    if restoration["counts"]["color"]:
        return
    original = image_from_bytes(restoration["current_bytes"])
    colorized = colorize_image(original)
    restoration["counts"]["color"] += 1
    bytes_data = image_to_bytes(colorized)
    restoration["story"] = None
    add_history_entry("ì»¬ëŸ¬ ë³µì› (ìë™)", bytes_data, note="í‘ë°± ì´ë¯¸ì§€ë¥¼ ê¸°ë³¸ íŒ”ë ˆíŠ¸ë¡œ ìƒ‰ë³´ì •í–ˆìŠµë‹ˆë‹¤.")


def can_run_operation(operation: str, allow_repeat: bool) -> bool:
    restoration = ensure_restoration_state()
    count = restoration["counts"].get(operation, 0)
    if allow_repeat:
        return count < 3
    return count == 0


def run_upscale():
    restoration = ensure_restoration_state()
    image = image_from_bytes(restoration["current_bytes"])
    upscaled = upscale_image(image)
    restoration["counts"]["upscale"] += 1
    bytes_data = image_to_bytes(upscaled)
    restoration["story"] = None
    add_history_entry("í•´ìƒë„ ì—…", bytes_data, note="ESRGAN ëŒ€ì²´ ì•Œê³ ë¦¬ì¦˜(ìƒ˜í”Œ)ìœ¼ë¡œ 2ë°° ì—…ìŠ¤ì¼€ì¼í–ˆìŠµë‹ˆë‹¤.")


def run_denoise():
    restoration = ensure_restoration_state()
    image = image_from_bytes(restoration["current_bytes"])
    denoised = denoise_image(image)
    restoration["counts"]["denoise"] += 1
    bytes_data = image_to_bytes(denoised)
    restoration["story"] = None
    add_history_entry("ë…¸ì´ì¦ˆ ì œê±°", bytes_data, note="NAFNet ëŒ€ì²´ í•„í„°(ìƒ˜í”Œ)ë¡œ ë…¸ì´ì¦ˆë¥¼ ì™„í™”í–ˆìŠµë‹ˆë‹¤.")


def run_story_generation():
    restoration = ensure_restoration_state()
    text = build_story(restoration["description"], restoration["counts"], restoration["photo_type"])
    restoration["counts"]["story"] += 1
    restoration["story"] = {
        "text": text,
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "status": dict(restoration["counts"]),
    }


# ------------------------------[ 5) ë³¸ë¬¸ UI ]----------------------------------
st.title("ğŸ“Œ ì‚¬ì§„ ë³µì› + ìŠ¤í† ë¦¬ ìƒì„±")

if "kakao_token" in st.session_state:
    st.success(f"ë¡œê·¸ì¸ë¨: {(nickname or 'ì¹´ì¹´ì˜¤ ì‚¬ìš©ì')}")
else:
    st.info("ì¹´ì¹´ì˜¤ ë¡œê·¸ì¸ì„ ì§„í–‰í•˜ë©´ ë³µì› ë‚´ì—­ì´ ì„¸ì…˜ì— ë³´ì¡´ë©ë‹ˆë‹¤.")

restoration_state = ensure_restoration_state()

with st.container():
    st.subheader("1. ì‚¬ì§„ ì—…ë¡œë“œ")
    photo_type = st.radio("ì‚¬ì§„ ìœ í˜•", ["í‘ë°±", "ì»¬ëŸ¬"], horizontal=True, key="photo_type_selector")
    description = st.text_input("ì‚¬ì§„ì— ëŒ€í•œ ê°„ë‹¨í•œ ì„¤ëª…", key="photo_description", placeholder="ì˜ˆ: 1970ë…„ëŒ€ ì™¸í• ì•„ë²„ì§€ì˜ ê²°í˜¼ì‹")
    uploaded_file = st.file_uploader("ì‚¬ì§„ íŒŒì¼ ì—…ë¡œë“œ", type=["png", "jpg", "jpeg", "bmp", "tiff"], key="photo_uploader")

    if uploaded_file is not None:
        file_bytes = uploaded_file.getvalue()
        digest = hashlib.sha1(file_bytes).hexdigest()
        if restoration_state["upload_digest"] != digest:
            reset_restoration(digest, file_bytes, photo_type, description)
            handle_auto_colorization(photo_type)
        else:
            restoration_state["description"] = description
            restoration_state["photo_type"] = photo_type

allow_repeat = st.checkbox("ê³ ê¸‰ ì˜µì…˜(ì‹¤í—˜ì ) - ë™ì¼ ì‘ì—… ë°˜ë³µ í—ˆìš© (ìµœëŒ€ 3íšŒ)")
if allow_repeat:
    st.warning("âš  ë™ì¼ ì‘ì—… ë°˜ë³µì€ ì²˜ë¦¬ ì‹œê°„ì´ ê¸¸ì–´ì§€ê±°ë‚˜ ì´ë¯¸ì§€ ì†ìƒì„ ìœ ë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")

if restoration_state["original_bytes"] is None:
    st.info("ì‚¬ì§„ì„ ì—…ë¡œë“œí•˜ë©´ ë³µì› ì˜µì…˜ì´ í™œì„±í™”ë©ë‹ˆë‹¤.")
else:
    st.subheader("2. ë³µì› ì˜µì…˜")

    cols = st.columns(3)
    with cols[0]:
        can_upscale = can_run_operation("upscale", allow_repeat)
        upscale_clicked = st.button("í•´ìƒë„ ì—…", use_container_width=True, disabled=not can_upscale)
        if upscale_clicked:
            run_upscale()
    with cols[1]:
        can_denoise = can_run_operation("denoise", allow_repeat)
        denoise_clicked = st.button("ë…¸ì´ì¦ˆ ì œê±°", use_container_width=True, disabled=not can_denoise)
        if denoise_clicked:
            run_denoise()
    with cols[2]:
        can_story = can_run_operation("story", allow_repeat)
        story_clicked = st.button("ìŠ¤í† ë¦¬ ìƒì„±", use_container_width=True, disabled=not can_story)
        if story_clicked:
            run_story_generation()

    st.divider()

    col_original, col_result = st.columns(2)
    with col_original:
        st.subheader("ì›ë³¸ ì´ë¯¸ì§€")
        st.image(restoration_state["original_bytes"], use_column_width=True)
        st.caption(format_status({"color": 0, "upscale": 0, "denoise": 0}))

    with col_result:
        st.subheader("ë³µì› ê²°ê³¼")
        if restoration_state["history"]:
            latest = restoration_state["history"][-1]
            st.image(latest["bytes"], use_column_width=True, caption=latest["label"])
            st.caption(format_status(latest["status"]))
            if latest.get("note"):
                st.markdown(f"*{latest['note']}*")
        else:
            st.info("ì•„ì§ ìˆ˜í–‰ëœ ë³µì› ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤.")

    if len(restoration_state["history"]) > 1:
        with st.expander("ì „ì²´ ì‘ì—… íˆìŠ¤í† ë¦¬"):
            for idx, entry in enumerate(restoration_state["history"], 1):
                st.markdown(f"**{idx}. {entry['label']}** ({entry['timestamp']})")
                st.image(entry["bytes"], use_column_width=True)
                st.caption(format_status(entry["status"]))
                if entry.get("note"):
                    st.write(entry["note"])
                st.markdown("---")

    if restoration_state.get("story"):
        st.subheader("ìŠ¤í† ë¦¬")
        story_info = restoration_state["story"]
        st.markdown(story_info["text"])
        st.caption(
            f"ìƒì„± ì‹œê°: {story_info['timestamp']} / {format_status(story_info['status'])}"
        )


st.markdown("---")
st.caption(
    "*DeOldify, ESRGAN, NAFNet ë“±ì˜ ì‹¤ì œ ëª¨ë¸ ì—°ë™ì„ ìœ„í•œ ìë¦¬ í‘œì‹œìë¡œ, í˜„ì¬ëŠ” ìƒ˜í”Œ í•„í„°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.*"
)